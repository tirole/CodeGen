<#@ template language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<# // セッター・ゲッター定義 #>
<#foreach(var member in Info.MemberVariableInfos) { 
        string upperCamelVariableName = char.ToUpper(member.VariableName[0]) + member.VariableName.Substring(1);
        string functionNameSuffix = Info.Name + upperCamelVariableName;
        string inputType = member.Type;
        string inputVariableName = member.VariableName;
        string memcpySize = "";
        string memcpySrcDstVariableName = "";
        string pointerGetterReturnType = "";
        bool isInputTypePointer = false;
        bool isArray = member.ArrayLength > 0;
        if(member.TypeSuffix != null && member.TypeSuffix != "")
        {
            inputType += " " + member.TypeSuffix;
            isInputTypePointer = member.TypeSuffix == "*";
        }

        if(isInputTypePointer)
        {
            inputVariableName = "p" + upperCamelVariableName;
            memcpySize = "sizeof(" + member.Type + ")";
            memcpySrcDstVariableName = inputVariableName;
            pointerGetterReturnType = inputType;
        }
        else if(isArray)
        {
            inputVariableName = member.VariableName + "[" + member.ArrayLength + "]";
            memcpySize = "sizeof(" + member.Type  + ")" + " * " + member.ArrayLength;
            memcpySrcDstVariableName = member.VariableName;
            pointerGetterReturnType = inputType + "*";
        }

        int bitLength = member.BitEnd - member.BitBegin + 1;

        // 配列は常に memcpy とする
        bool isNeedsMemcpy = (isArray || isInputTypePointer) && ((bitLength % 32) == 0);
        if(isNeedsMemcpy)
        {
            if(member.HasModifier())
            {
                throw new System.InvalidOperationException("Cannot handle modifier for memcpy.\n");
            }
            if(member.BitBegin != 0)
            {
                throw new System.InvalidOperationException("Invalid bit begin, cannot perform memcpy.\n");
            }
        }

        bool isExact32bitVariable = (member.BitEnd - member.BitBegin) == 31;
        bool isExact64bitVariable = (member.BitEnd - member.BitBegin) == 63;
        bool isGreaterThan32bit = (member.BitEnd - member.BitBegin) >= 32;
        bool isZeroStartVariable = (member.BitBegin == 0);
        // 現状は 33bit 以上でしか存在しないので条件を決め打ち
        bool isCrossingVariable =  isGreaterThan32bit && !isZeroStartVariable;
        
        string inputTempValueString = "";
        string inputTempValueType = "";
        string returnValueString = "";
        string outputTempValueType = "";
        // for general case
        string outputValueString = "";

        if(isGreaterThan32bit)
        {
            inputTempValueType = "uint64_t";
        }
        else
        {
            inputTempValueType = "uint32_t";
        }

        if(isInputTypePointer)
        {
            inputTempValueString = "*reinterpret_cast<" + inputTempValueType + "*>(" + inputVariableName + ")";
            returnValueString = "*reinterpret_cast<" + inputType + ">(&outputVal)";
            outputTempValueType = inputTempValueType;
        }
        else
        {
            inputTempValueString = "static_cast<" + inputTempValueType + ">(" + member.VariableName + ")";
            returnValueString = "outputVal";
            outputTempValueType = member.Type;
            if(inputType == "bool")
            {
                outputValueString = "((pDesc->data[uint32ArrayIndex] & mask) >> bitOffset) != 0";
            }
            else
            {
                outputValueString = "static_cast<" + outputTempValueType + ">((pDesc->data[uint32ArrayIndex] & mask) >> bitOffset)";
            }
        }

#>
<#        if(isNeedsMemcpy) { #>
inline
void Set<#=functionNameSuffix#>(<#=Info.Name#>* pDesc, const <#=inputType#> <#=inputVariableName#>)
{
    constexpr int uint32ArrayIndex = <#=member.OffsetIn4ByteUnit #>;
    memcpy(&pDesc->data[uint32ArrayIndex], <#=memcpySrcDstVariableName#>, <#=memcpySize #>);
}
<#        }else {#>
inline
void Set<#=functionNameSuffix#>(<#=Info.Name#>* pDesc, <#=inputType#> <#=inputVariableName#>)
{
<#            if(member.RequirementInfos != null) { #>
<#                foreach(var info in member.RequirementInfos) { #>
<#                    if(info.Type != RequirementInfo.RequirementType.NoRequirement) { #>
    <#=                            info.GetString(member.VariableName) #>
<#                    } #>
<#                } #>
<#            } #>
<#            if((isExact64bitVariable || isExact32bitVariable) && isZeroStartVariable) { #>
    constexpr int uint32ArrayIndex = <#=                    member.OffsetIn4ByteUnit #>;
    auto pOut = reinterpret_cast<<#=                    member.Type #>*>(&pDesc->data[uint32ArrayIndex]);
    *pOut = <#=member.VariableName #>;
<#                if(member.HasModifier()) { #>
    <#=member.GetModifierString("*pOut") #>;
<#                } #>
<#            } else if(isCrossingVariable) { #>
    constexpr int uint32ArrayIndex = <#=                    member.OffsetIn4ByteUnit #>;
    constexpr int bitOffset = <#=                    member.BitBegin #>;
    constexpr int lowBitLength = 32 - bitOffset;
    constexpr uint32_t lowBitMask = static_cast<uint32_t>(~(-1LL << lowBitLength ));
    constexpr int highBitLength = (<#=                    member.BitEnd #> - <#=                    member.BitBegin#> + 1) - lowBitLength;
    constexpr uint32_t highBitMask = static_cast<uint32_t>(~(-1LL << highBitLength));

    <#=inputTempValueType #> inputVal = <#=inputTempValueString #>;
<#                if(member.HasModifier()) { #>
    <#=                        member.GetModifierString() #>;
<#                } #>
    int lowVal = inputVal & lowBitMask;
    int highVal = (inputVal >> lowBitLength) & highBitMask;

    // low side
    pDesc->data[uint32ArrayIndex] &= ~(lowBitMask << bitOffset);
    pDesc->data[uint32ArrayIndex] |= lowVal << bitOffset;
    // high side
    pDesc->data[uint32ArrayIndex + 1] &= ~highBitMask;
    pDesc->data[uint32ArrayIndex + 1] |= highVal;
    
<#            } else { #>
    constexpr int uint32ArrayIndex = <#=                    member.OffsetIn4ByteUnit #>;
    constexpr int bitOffset = <#=                    member.BitBegin #>;
    constexpr int bitLength = (<#=                    member.BitEnd #> - bitOffset) + 1;
    constexpr uint32_t mask = static_cast<uint32_t>(~(-1LL << bitLength ));
    <#=inputTempValueType #> inputVal = <#=inputTempValueString #>;
<#                if(member.HasModifier()) { #>
    <#=                        member.GetModifierString() #>;
<#                } #>
    pDesc->data[uint32ArrayIndex] |= (inputVal & mask) << bitOffset;
<#            } #>
}
<#        } #>

<#        if(isNeedsMemcpy) { #>
inline
void Get<#=functionNameSuffix#>(<#=inputType#> <#=inputVariableName#>, const <#=Info.Name #>* pDesc)
{
    constexpr int uint32ArrayIndex = <#=member.OffsetIn4ByteUnit #>;
    memcpy(<#=memcpySrcDstVariableName#>, &pDesc->data[uint32ArrayIndex], <#=memcpySize #>);
}

inline
<#=pointerGetterReturnType#> Get<#=functionNameSuffix#>Pointer(<#=Info.Name #>* pDesc)
{
    constexpr int uint32ArrayIndex = <#=member.OffsetIn4ByteUnit #>;
    return reinterpret_cast<<#=pointerGetterReturnType#>>(&pDesc->data[uint32ArrayIndex]);
}
<#        }else {#>
inline
<#=member.Type #> Get<#=functionNameSuffix#>(const <#=Info.Name #>* pDesc)
{
<#            if((member.BitEnd - member.BitBegin) == 63) { #>
    constexpr int uint32ArrayIndex = <#=                    member.OffsetIn4ByteUnit #>;
    auto pOut = reinterpret_cast<const <#=                    member.Type #>*>(&pDesc->data[uint32ArrayIndex]);
    return *pOut;
<#            } else if((member.BitEnd - member.BitBegin) >= 32 && (member.BitBegin != 0)) { #>
    constexpr int uint32ArrayIndex = <#=                    member.OffsetIn4ByteUnit #>;
    constexpr int bitOffset = <#=                    member.BitBegin #>;
    constexpr int lowBitLength = 32 - bitOffset;
    constexpr uint32_t lowBitMask = static_cast<uint32_t>(~(-1LL << lowBitLength));
    constexpr int highBitLength = (<#=                    member.BitEnd #> - <#=                    member.BitBegin #> + 1) - lowBitLength;
    constexpr uint32_t highBitMask = static_cast<uint32_t>(~(-1LL << highBitLength));

    <#=                    member.Type #> outputVal = 0;
    outputVal = (pDesc->data[uint32ArrayIndex] & (lowBitMask << bitOffset)) >> bitOffset;
    outputVal |= static_cast<uint64_t>((pDesc->data[uint32ArrayIndex + 1] & highBitMask)) << lowBitLength;
    return <#=returnValueString #>;
<#            } else { #>
    constexpr int uint32ArrayIndex = <#=                    member.OffsetIn4ByteUnit #>;
    constexpr int bitOffset = <#=                    member.BitBegin #>;
    constexpr int bitLength = (<#=                    member.BitEnd #> - bitOffset) + 1;
    constexpr uint32_t mask = static_cast<uint32_t>(~(-1LL << bitLength )) << bitOffset;
    <#=outputTempValueType #> outputVal = <#=outputValueString #>;
    return <#=returnValueString #>;
<#            } #>
}
<#        } #>

<#    } #>