<#@ template language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<# // セッター・ゲッター定義 #>
<#  foreach(var member in Info.MemberVariableInfos) { #>
<#if((member.BitEnd - member.BitBegin) > 63) { #>
inline
void Set<#=Info.Name #><#=char.ToUpper(member.VariableName[0]) + member.VariableName.Substring(1) #>(<#=Info.Name#>* pDesc, const <#=member.Type#> <#=member.VariableName#>[<#=member.ArrayLength #>])
{
    constexpr int uint32ArrayIndex = <#=member.OffsetIn4ByteUnit #>;
    memcpy(&pDesc->data[uint32ArrayIndex], <#=member.VariableName#>, sizeof(<#=member.Type #>) * <#=member.ArrayLength #>);
}
<#}else {#>
inline
void Set<#=Info.Name #><#=char.ToUpper(member.VariableName[0]) + member.VariableName.Substring(1) #>(<#=Info.Name#>* pDesc, <#=member.Type#> <#=member.VariableName#>)
{
<#if(member.RequirementInfos != null) { #>
<#foreach(var info in member.RequirementInfos) { #>
<#if(info.Type != RequirementInfo.RequirementType.NoRequirement) { #>
    <#=info.GetString(member.VariableName) #>
<#} #>
<#} #>
<#} #>
<#if((member.BitEnd - member.BitBegin) == 63) { #>
    constexpr int uint32ArrayIndex = <#=member.OffsetIn4ByteUnit #>;
    auto pOut = reinterpret_cast<<#=member.Type #>*>(&pDesc->data[uint32ArrayIndex]);
    *pOut = <#=member.VariableName #>;
<#} else { #>
    constexpr int uint32ArrayIndex = <#=member.OffsetIn4ByteUnit #>;
    constexpr int bitOffset = <#=member.BitBegin #>;
    constexpr int bitLength = (<#=member.BitEnd #> - bitOffset) + 1;
    constexpr int mask = static_cast<int>(~(static_cast<int64_t>(-1) << bitLength ));
    int inputVal = static_cast<int>(<#=member.VariableName #>);
    pDesc->data[uint32ArrayIndex] |= (inputVal & mask) << bitOffset;
<#} #>
}
<#} #>

<#if((member.BitEnd - member.BitBegin) > 63) { #>
inline
void Get<#=Info.Name #><#=char.ToUpper(member.VariableName[0]) + member.VariableName.Substring(1) #>(<#=member.Type #> <#=member.VariableName #>[<#=member.ArrayLength #>], const <#=Info.Name #>* pDesc)
{
    constexpr int uint32ArrayIndex = <#=member.OffsetIn4ByteUnit #>;
    memcpy(<#=member.VariableName#>, &pDesc->data[uint32ArrayIndex], sizeof(<#=member.Type #>) * <#=member.ArrayLength #>);
}
<#}else {#>
<#=member.Type #> Get<#=Info.Name #><#=char.ToUpper(member.VariableName[0]) + member.VariableName.Substring(1) #>(const <#=Info.Name #>* pDesc)
{
<#if((member.BitEnd - member.BitBegin) == 63) { #>
    constexpr int uint32ArrayIndex = <#=member.OffsetIn4ByteUnit #>;
    auto pOut = reinterpret_cast<const <#=member.Type #>*>(&pDesc->data[uint32ArrayIndex]);
    return *pOut;
<#} else { #>
    constexpr int uint32ArrayIndex = <#=member.OffsetIn4ByteUnit #>;
    constexpr int bitOffset = <#=member.BitBegin #>;
    constexpr int bitLength = (<#=member.BitEnd #> - bitOffset) + 1;
    constexpr int mask = static_cast<int>(~(static_cast<int64_t>(-1) << bitLength )) << bitOffset;
    <#=member.Type #> outputVal = static_cast<<#=member.Type #>>((pDesc->data[uint32ArrayIndex] & mask) >> bitOffset);
    return outputVal;
<#} #>
}
<#} #>

<#  } #>